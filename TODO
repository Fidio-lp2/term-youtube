何をどうやって実装すればいいのか全くわかんにゃ〜い^^^^^
どうやってどうするんやマジで

stream.pyのもともとの設計理念はpafyとvlcモジュールを使ってurlさえあればターミナル上で音楽が聴けるってことだからなぁ...どうしまshow timeって感じだわwwwwww

...クラスメソッドしか用意してないし、もともとインスタンスとして利用してもらいたいって感じで実装した(ライブラリとして実装してない)から、なぁ..............うーんこのうーんこはうーんこうんこうんこ

まあ、もともとインスタンスとして利用して欲しいってことは、インスタンスのみで十分なストリーミングが可能にしていた方がいいのかもしれぬな...(それだとコールバック関数をどう定義するかって言うのもあるますがなぁ)

ちゃんとかんがえる...
　まず、stream.py内にwhile文を記述したときのことを考える。
　その場合に、生成したインスタンスの関数を呼ぶのはどこからなのかと言う問題が発生する。もし、マルチスレッドでwhile文を回していた場合も、


今出ているKeyErrorだが、ネットくんの情報によると、get()関数の場合はkeyerrorではなくnoneが変えるので処理がストップすることはなくなるため、ライブラリを書き換えることによってその処理を行う方針で行こうと思う。

DisplayYoutubeの設計
何をするものなのか
　インスタンス化し、外部からメソッドを呼び出すことによって、画面の描画を変更、引数によって変えたりするということです。また、内部にstreamオブジェクトを保持し、getメソッドによって画面描画を変更したりします。(getかどうかはわからないですが)

メンバ変数
・
・

メンバ関数   


今やりたいこと

git commandのように、

term-youtube search [video name]
term-youtube add [video name]
term-youtube list

とかでstreamをバックグラウンドで実行しながらどこからでも参照できるようにしたいと思っております！

そこで問題になっているのが、どのようにしてdaemonを有効活用するかなのですなこれが...
    input()を使おうにも、daemonを利用していたらinput()さえ握りつぶされてしまうのですな。考えものであります。


<具体的な処理を自分の頭の中を整理するためにフローしてみる>

フローチャートは同じディレクトリないに入れまあす


daemonの問題ですが、daemon moduleに付属しているopen functionとclose functionを利用することによって、daemon化を切り替えることができるため、良いんではないかなぁ?????

(term-youtube search) とかの時だけdaemonを消すとかさ。A


いやわけわからんことに、daemonを一回closeしてしまうとなぜかpythonの法に復帰するんじゃなくてプロセス自体が終わってしまうという謎の事態に陥っているのさあああ！A


まじでなんでやねんぼけええええええ

どうしようかマジで

タスク
・daemonのプロセス復帰問題
・term-youtubeの形式

...プロセスを復帰しなくても、インタラクティブに行える方式にすれば良いのではないか？

↑そうしよう！





インタラクティブモードとTUIモードの二つを使えるようにする！
(まずは院タラクティブモードの実装を考える。)



インタラクティブモードの実装できましたああああああああ！

うれっっっっっっっっっっっっっっっっっっp
うんち

これからどうするか

・mecabの形態素解析によっておすすめのやつ
・logファイルを用意して、コマンドを前回利用時のやつを辿れるようにしたり、
　どの曲や動画を一番聞いたのかを確認する。
・今どの曲を再生しているのか、どこら辺を再生しているのか、今再生している曲や、指定した曲の情報取得

というかシンプルに見やすくしたい

・また、プロンプトを容易に変更できるようにする。


・インタラクティブモード(以下iモード)で、容易に自作のプレイリストを作れるようにする。







Dataの表示について

表示するもの

タイトル、チャンネル名、再生回数、いいね、悪いね、公開日、再生長さ、URL

=------------------=
(♪) TITLE [length]
channel
likes disliked
xxxx views published
=------------------=


Statusの表示について

表示するもの

今何を再生しているのか、どこら辺を再生しているのか、現在のプレイリストには何曲入っていて今何曲目なのか
現在のモードは何か。現在のプレイリストはなんという名前なのか。

<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~>
 ♪ Now Playing [song title] [xxxx/XXXX]
 playlist name [x/X]
 current mode
<~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~>




次に、プレイリストの作成について、お話しします...
    
    ソースコード自体はstream.pyに入れようと思っている次第でございます

    処理の流れ

    playlist
        現在存在するプレイリストを一覧表示する。
        一応、作った日と、長さを表示する。

    make [name]
    ｜
    [name]に合致するplaylistの名前を探す
    ｜
    ＝あるならば, そのプレイリストが既に存在していることを伝え、処理を停止する。＜
    ｜
    ＝ないならば, stream.pyないの現在のmy_videosから、json形式にして保存できる形のプレイリストを作成し、
        playlist.jsonに後生大事に保存する。

    open [name]
    ｜
    [name]に合致するplaylistの名前を探す
    ｜
    ＝あるのならば、一旦今のプレイリストをデタッチして(保存はするぞ！)、playlist.jsonに後生大事に保存されてある
    ｜   データを拾ってきて、add songsとかでplayerlistを新しく作って代入する。
    ｜
    ＝ないのならば、ない旨を伝える。

    update [name]
    ｜
    [name]に合致するplaylistの名前を探す
    ｜
    ＝あれば、一応[Y/N]で確認してからカレントプレイリストで[name]のプレイリストを上書き保存する。
    ｜
    ＝なければ、ない旨を伝え処理を終了する。

    delete [name]
    ｜
    [name]に合致するplaylistの名前を探す
    ｜
    ＝あれば、一応確認してから消す。
    ｜
    ＝なければその旨を伝え処理を終了する.



    プレイリストの作成、ウォッチリストの管理について。

    まず、名前がNoneのプレイリストは作成不可とする。(現在の判定が難しいため。)

    また、ファイルを開くのは保守の関係で、with open構文を使ってそのelif文の中のみとする。(長時間ファイル開いてたら怖いから)

    <ここで問題になっているのは、一度開いたファイルのインスタンス(media_listとvideo情報)を、辞書型にして保存してしまうかということ>



# 2021/10/20 fix
修正する
エラー処理
ディスコードbotのようにやる？
保存モード


















































